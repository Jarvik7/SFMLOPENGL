Diary:
2014-0-25
-At present, the state of my renderer is as follows. The entire BSP geometry is correctly rendered. There is no culling. In small maps this still results in a good FPS, but importing a larger QuakeLive map results in unusable FPS.
-Diffuse texturing is working, though there are some polygons which don't get a texture (top of spire in q3dm1).
-Vertex lighting is working, though some parts of the tessellated meshes seem to not get colored (arches).
-3d movement works perfectly, but only in a "noclip" style way. There is no jumping/crouching.
-Textures are stored in an old-fashioned way (not texstorage), and has anisotropic filtering/mipmapping.
-The entities/lightmap lumps are parsed, but not much is actually done with the data. Spawn points are read in as camera positions and the music for the map is played. The lights are imported into a vector of "lightPos", but they are not rendered yet and the data has not been checked for correctness.
-The renderer itself should be free of all deprecated functionality and run in 3.2 core, but this is untested. The FPS counter uses SFML functions and will likely not work. (Uses vert/frag shaders and vao for all data)
-Currently gets ~155fps on work PC with high antialiasing enabled.

Current near/medium goals are:
- Refactor code so that all Q3-only functionality is in the q3bsp file/class
- Figure out proper way to handle all the vertex data. Sorting by texture reduces the speed hit to change bindings, but we still need to make 2 passes (one for meshes one for patches), and it causes difficulty for changing other material properties (transparency, animated textures, q3 shaders, etc.) The current system can be changed to 1 pass by interleaving mesh and patch rendering, but this is just a bandaid on a bigger problem.
- Implement more effects in shaders in 2 stages: Normal q3 shader effects, and fancy postprocessing (bloom, hdr, dof, etc)
- Implement a way to cull un-needed geometry. I would prefer to do this using hardware occlusion culling to enable large outdoor scenes and get away from needing pre-baked PVS/portals. May need a way to automatically generate bounding boxes for geometry.
- Figure out how to implement moving geometry (doors/lifts). Should this be done with a geometry shader?
- Implement multitexturing (particularly lightmaps and bumpmaps). 3 levels of lighting quality should ultimately be selectable (vertex lighting, lightmaps, fully dynamic)
- Implement a unified lighting and shadow deferred lighting renderer to handle the dynamic lights
- Implement MD3 etc renderer and draw in-map entities
- Expand BSP support to Q1/2/Live/RTCW/Doom3/etc

Missing Q3 game stuff:
Render MD3 models (pick-ups, player models, weapon)
Shader: Animated textures
Shader: Skybox
Other shaders
Moving geometry (doors, lifts)
Collision detection
Sound (links in to collision detection to find proper footstep sound etc)

Idea BSP-based render flow:?
Pre-render prep:
-Get list of visible faces
-- Get current position (x,y,z)

-- Crawl bsp tree nodes to find what cluster leaf we're in (and thus what cluster)
---Check child 0 bounding box. No? Check child 1. Repeat until we fail both children.
---Check the cluster of the leaf that node points to (it's pointing at one right?)

--Loop through visdata to find all other clusters that are visible
--Dump their face numbers into a vector, this is all potentially visible faces
--Group faces by opaque/translucent
--Sort opaque by texture/shader (mesh and poly)
--Draw opaque from front to back
--Sort translucent ""
--Draw translucent from back to front


-Separate into groups determined by if they are plain surfaces or have shaders
-Sort by texture
-Separate by if they are meshes or patches
Render order:
-Draw all plain surfaces in order of texture. Do meshes and patches in same set
-Draw shaded surfaces

The above lists should just generate indices based on crawling of the tree and then grouping/sorting.
List 1: Plain meshes (ordered by texture): 2d vector[number of textures][number of faces]
List 2: Plain patches (ordered by texture) "
List 3: Shaded meshes (ordered by shader) ", TRIANGLES
List 4: Shaded patches (ordered by shader) ", TRIANGLE_STRIP

This should work aside from anything with effects. They and any other fancy attributes should be treated as another unique shader group in a list 5?

I would prefer to do this with a more modern solution than just parsing the built in BSP tree with PVS. Octrees seem to be more modern and suited to outdoor maps. Portals (Doom3) require manual placement and may not work with large areas, so are not suited to a universal solution. Occulusion culling seems the most modern, but can the generation of bounding boxes be automated? Can we HW accelerate it in OpenGL 3.3?

Quake 1/2/3: BSPtree with PVS generated by map editor
Doom 3: Portals
Half Life: ?
Tesseract: ?
IOQuake 3: ?
etc.



Renderlist:

Data:

Base geometry:
Re-arrange to use fewer buffer objects and glMultiDrawElements/glPrimitiveRestartindex. At present we have 1 vert object and <numTextures> index objects + 1 for each tessellated mesh
The data should also include the tesselated meshes.
Two calls to glMultiDrawElements will be needed. (GL_TRIANGLES for normal geometry and GL_TRIANGLE_STRIP for tessellated)
? What to do about moving world geometry? models[0] lists the static geometry
? What to do about faces with shaders?
? How to manage all the different settings a face can have? Can this be done nicely in GLSL on a per-vertex/frag basis?
? There are still a few VERY small holes in Q3DM1

- Buffer 1: All vertices
- Buffer 2: All indices, sorted by texture
- Array 1: Number of indices to use for each texture group
- Array 2: Offsets into Buffer 2 for start of each texture group

The arrays can likely be tweaked to switch on/off groups of faces for culling.


Render function:



Q3 Dev Notes:

Currently working:
-Fixed world geometry
-Tesselated surfaces
-Plain diffuse textures /w coords
-Vertex colors

Not working:
- Shaders
- Lighting
- Physics/collision detection
- Entities (spawn location, models, etc)
- Culling
- No model loader/animation
- Sound

To do:
-Convert renderer to shader pipeline & eliminate deprecated functionality
--Step 1: Handle matrices myself w/ GLM
--Step 2: Process verts & fragments in GLSL

-Add lighting
-Do this with actual dynamic lights as specified in the entities list. Can skip lightmap support
-Long-goal: deferred lighting /w volumetric shadows, self-shadowing, etc

-Physics
-Short-goal: simple collision detection
-Long-goal: proper physics using Havok etc

-Culling
-Ignore BSP datastructures and do something more modern?

-Load models
-Q3 uses keyframes. Add Doom3 skeletal support

-Sound
-Use OpenAl instead of crappo SFML sound
-Support mp3 for music instead of wav